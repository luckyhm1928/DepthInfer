% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/depthInferFoFR.R
\name{depthInferFoFR}
\alias{depthInferFoFR}
\title{Depth-based inference for mean response in function-on-function regression models}
\usage{
depthInferFoFR(
  X,
  Y,
  X0,
  h_max = 20,
  rho_vec = c(seq(0.85, 0.95, by = 0.05), 0.99),
  u_vec = c(0.5, 0.4, 0.3, 0.2, 0.1, 0.05, 0.01, 0.001),
  Mproj = 20000,
  Mbts = 1000
)
}
\arguments{
\item{X}{An n by pX matrix of functional regressors. Each row represent one observed curve.}

\item{Y}{An n by pY matrix of functional responses. Each row represent one observed curve.}

\item{h_max}{An integer. The largest number of truncation levels that are used for test statistics based on functional principal components.}

\item{rho_vec}{A numeric vector of threshold values used for fraction of variance explained. These must be within zero and one.}

\item{u_vec}{A numerical vector of quantile levels to determine the regularizations for regularized halfspace and projection depths and the bandwidths for kernel depth.}

\item{Mproj}{An integer. The number of random projections used to approximate the regularized halfspace and projection depths.}

\item{Mbts}{An integer. The number of bootstrap resamples used for depth-based inference.}
}
\value{
A list containing the p-values of the following statistics. All p-values are given across new functional predictors X0 and threshold levels in rho_vec.
\item{RD}{The depth p-values from the regularized halfspace depth (HD), the regularized projection depth (PD), and the tie-broken regularized halfspace depth (HDtb) over quantile levels in u_vec. The regularization was done by both standard deviation and median absoluted deviation of the projecitons.}
\item{KD}{The depth p-value from the kernel depth over quantile levels in u_vec.}
\item{OneD}{The p-values from the classical summary test statistics: the squared L2 norm (L2) and supremum norm (sup)}
}
\description{
Conduct mean response inference for function-on-function regression (Yeon, 2026+)
with kernel (h-mode) depth, regularized halfspace depth, and regularized projection depth.
}
\examples{

ev_poly = function(a, c, J){
  dt = c*(1:J)^(-a)
  ld1 = c*VGAM::zeta(a)
  ld = c(ld1, sapply(1:(J-1), function(j){ld1 - sum(dt[1:j])}))
  return(ld)
}

#'set.seed(20260212)
tt = 50; tGrid_ttt = seq(0, 1, len=tt+1);
tGrid = tGrid_ttt[1:tt]
diffrange = diff(tGrid)[1] + diff(range(tGrid))       # when using left points
scal = diffrange / tt   # scaling factor for integration

Jtrue=20 # rows are functions in phi

# orthonormal systems

# trigonometric functions
phi_base = t(fda::fourier(tGrid_ttt, 2*Jtrue))[,1:tt]
phi = phi_base[(1:Jtrue),]
# orthonormalized monomials
mono = t(sapply(1:Jtrue, function(j)tGrid^j))
phi_mono = DepthInfer:::orthoL2Equidense(mono, tGrid)
# orthonormalized Chebyshev functions
cheb = t(sapply(1:Jtrue, function(j)pracma::chebPoly(j, 2*tGrid-1)))
phi_cheb = DepthInfer:::orthoL2Equidense(cheb, tGrid)

# eigenvalues
a1 = 2.5; a2 = 3.5
ga1  = ev_poly(a1, 2, Jtrue) # a=2.5
ga2  = ev_poly(a2, 2, Jtrue) # a=3.5

# slope operators

J0 = 5; Bscal = 2;
Wbetaj = rbinom(2*J0, 1, 0.5)*2-1

Bnull1 = Reduce("+",lapply(J0+1:J0, function(j){
  Bscal*j^(-(1.5)) *Wbetaj[j]* outer(phi_mono[j,], phi_mono[j,])
}))
Balter1 = Reduce("+",lapply(1:(2*J0), function(j){
  Bscal*j^(-(1.5)) *Wbetaj[j]* outer(phi[j,], phi[j,])
}))
Bnull2 = Reduce("+",lapply(J0+1:J0, function(j){
  Bscal*j^(-(2.5)) *Wbetaj[j]* outer(phi_mono[j,], phi_mono[j,])
}))
Balter2 = Reduce("+",lapply(1:(2*J0), function(j){
  Bscal*j^(-(2.5)) *Wbetaj[j]* outer(phi[j,], phi[j,])
}))
c_vec = seq(0,1,by=0.2)   # degrees of alternative

rexp_cent1 = function(n){rexp(n)-1} # centered exponential distribution
simX = function(n, Jtrue, rdist_Wj, rdist_xi, ga, phi){
  WjX = matrix(rdist_Wj(n*Jtrue), n, Jtrue)
    # xiX = rexp(n) - 1
  xiX = rdist_xi(n)
  Xfpc = t(sqrt(ga) * t(xiX*WjX))
  X = Xfpc \%*\% phi
  colnames(X) = paste0("t", 1:ncol(phi))
  rownames(X) = paste0("i", 1:n)
  return(X)
}

# ==== set scenarios ====
n_vec = c(50, 200, 1000)
n = n_vec[1]; iiB=1; ii_c=6
if(iiB==1){ Bnull=Bnull1;Balter=Balter1
}else if(iiB==2){ Bnull=Bnull2;Balter=Balter2
}
c = c_vec[ii_c]
B = (1-c)*Bnull + c*Balter
colnames(B) = paste0("t",1:ncol(B))
rownames(B) = paste0("t",1:nrow(B))

evX=xiX=evEr=xiEr=1
if(evX==1){ gaX=ga1 # a=2.5
}else{ gaX=ga2 # a=3.5
}
if(xiX==1){ rX=rnorm # \xi \sim \nd(0,1)
}else{ rX=rexp_cent1 # \xi \sim \Exp(1)-1
}
if(evEr==1){ gaEr=ga1 # a=2.5
}else{ gaEr=ga2 # a=3.5
}
if(xiEr==1){ rEr=rnorm # \xi \sim \nd(0,1)
}else{ rEr=rexp_cent1 # \xi \sim \Exp(1)-1
}


# ========= data generation ========
X = simX(n, Jtrue, rnorm, rX, gaX, phi_mono)
er = simX(n, Jtrue, rnorm, rEr, gaEr, phi_cheb)
BX = t(B \%*\% t(X) * scal)
Y = BX + er

# new predictors
n0=1 # It can be more than 1
X0 = simX(n0, J0, rnorm, rX, gaX[1:J0], phi_mono[1:J0,])

res = depthInferFoFR(X, Y, X0, Mproj=15)

}
\references{
Yeon, H. (2026) Inference for function-on-function regression: central limit theorem and residual bootstrap. Statistics and Its Interface. To appear

Yeon, H. (2026+) Effective and flexible depth-based inference for functional parameters. In preparation
}
\seealso{
\code{\link{KD}}
\code{\link{RegDepth}}
\code{\link{depthInfer2test}}
}
