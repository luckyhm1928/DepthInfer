% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/depthInfer2test.R
\name{depthInfer2test}
\alias{depthInfer2test}
\title{Depth-based inference: two-sample functional mean tests}
\usage{
depthInfer2test(
  X1,
  X2,
  h_max = 20,
  rho_vec = c(seq(0.85, 0.95, by = 0.05), 0.99),
  u_vec = c(0.5, 0.4, 0.3, 0.2, 0.1, 0.05, 0.01, 0.001),
  Mproj = 20000,
  B = 1000
)
}
\arguments{
\item{X1}{An n1 by p matrix of functional data of the first group. Each row represent one observed curve.}

\item{X2}{An n2 by p matrix of functional data of the second group. Each row represent one observed curve.}

\item{h_max}{An integer. The largest number of truncation levels that are used for test statistics based on functional principal components.}

\item{rho_vec}{A numeric vector of threshold values used for fraction of variance explained. These must be within zero and one.}

\item{u_vec}{A numerical vector of quantile levels to determine the regularizations for regularized halfspace and projection depths and the bandwidths for kernel depth.}

\item{Mproj}{An integer. The number of random projections used to approximate the regularized halfspace and projection depths.}

\item{B}{An integer. The number of bootstrap resamples used for depth-based inference.}
}
\value{
A list containing the p-values of the following statistics.
\item{ITD}{The depth p-value from the integrated depth}
\item{IFD}{The depth p-value from the infimal depth}
\item{RD}{The depth p-values from the regularized halfspace depth (HD), the regularized projection depth (PD), and the tie-broken regularized halfspace depth (HDtb) over quantile levels in u_vec. The regularization was done by both standard deviation and median absoluted deviation of the projecitons.}
\item{KD}{The depth p-value from the kernel depth over quantile levels in u_vec.}
\item{BTS1d}{The p-values from the classical summary test statistics: the squared L2 norm (L2normSq), supremum norm (SupNorm), integrated pointwise F statistic (Fint), and maximal pointwise F statistic (Fmax).}
\item{BTSfpc}{The p-values from the test statistics based on functional principal components analysis: QuadInv (Horvath et al., 2013) and QuadMul (Sharghi Ghale-Joogh and Hosseini-Nasab, 2018).}
}
\description{
Conduct two-sample functional mean tests using depth statistics (Yeon, 2026+)
with kernel (h-mode) depth, regularized halfspace depth, regularized projection depth,
integrated depth, and inifimal depth
}
\examples{

ev_poly = function(a, c, J){
  dt = c*(1:J)^(-a)
  ld1 = c*VGAM::zeta(a)
  ld = c(ld1, sapply(1:(J-1), function(j){ld1 - sum(dt[1:j])}))
  return(ld)
}

set.seed(20260212)
tt = 50; tGrid_ttt = seq(0, 1, len=tt+1); 
tGrid = tGrid_ttt[1:tt]
diffrange = diff(tGrid)[1] + diff(range(tGrid))       # when using left points
scal = diffrange / tt   # scaling factor for integration

Jtrue=20 # rows are functions in phi

# eigenvalues
ga_rough  = ev_poly(2.5, 2, Jtrue) # a=2.5
ga_smooth = ev_poly(5, 2, Jtrue)   # a=5

# orthonormal systems

# trigonometric functions
phi_base = t(fda::fourier(tGrid_ttt, 2*Jtrue))[,1:tt]  
phi = phi_base[(1:Jtrue),]
# orthonormalized monomials
mono = t(sapply(1:Jtrue, function(j)tGrid^j))
phi_mono = DepthInfer:::orthoL2Equidense(mono, tGrid)
# orthonormalized Chebyshev functions
cheb = t(sapply(1:Jtrue, function(j)pracma::chebPoly(j, 2*tGrid-1)))
phi_cheb = DepthInfer:::orthoL2Equidense(cheb, tGrid)
# orthonormalized spline functions
rangeval = c(0, 1); nbasis = Jtrue
bs_basis <- fda::create.bspline.basis(
  rangeval = rangeval, nbasis = nbasis, norder = 4
)  # norder = degree + 1
phi_splines = DepthInfer:::orthoL2Equidense(
  t(fda::eval.basis(tGrid, bs_basis)), tGrid
)

# alternative mean functions
mu1Alter_mat = 1*rbind(
  mag = rep(1, tt), # mag
  jump = sapply(tGrid, function(t){ifelse(t<=0.2, -1, 1)}), # jump
  peak = sapply(tGrid, function(t){ifelse(t>0.2&t<=0.4, 1, -1)}), # peak
  lin = 2*tGrid-1, # lin
  quad = 8*(tGrid-1/2)^2-1, # quad
  cubic = 12*sqrt(3)*tGrid*(tGrid-1/2)*(tGrid-1), # cubic
  wiggle = sin(10*pi*(tGrid-0.05)) # wiggle
)

c_vec = seq(0,1,by=0.2)
mu1 = rep(0,tt); c_alter=c_vec[6]; Htype=4 # (linear alternative)
mu2 = (1-c_alter)*mu1 + c_alter*mu1Alter_mat[Htype,]

eveq = TRUE # TRUE: eigenvalues are equal
efeq = TRUE # TRUE: eigenfunctions are equal
if(eveq){ ga1 = ga2 = ga_rough # equal eigenvalues 
}else{ ga1 = ga_smooth; ga2 = ga_rough # unequal eigenvalues
}
if(efeq){ phi1 = phi; phi2 = phi # equal eigenfunctions
}else{ phi1 = phi_mono; phi2 = phi_cheb # unequal eigenfunctions
}

n=50; n1 = n2 = n/2 
idx1 = as.logical(c(rep(1,n1), rep(0,n2))); idx2 = !idx1


# # # # # # # # # # # 
# generate data

Wj = matrix(rnorm(n*Jtrue), n, Jtrue); xi_type=1
if(xi_type==2){ xi = rexp(n) - 1 # normal*exp FPC scores
}else if(xi_type==1){ xi = rnorm(n) # normal*normal FPC scores
}else{ xi = rep(1,n) # independent FPC scores
}

Xfpc = matrix(0, n, Jtrue)
Xfpc[idx1,] = t(sqrt(ga1) * t(xi[idx1]*Wj[idx1,]))
Xfpc[idx2,] = t(sqrt(ga2) * t(xi[idx2]*Wj[idx2,]))

X = matrix(0, n, tt)
X[idx1,] = t(mu1 + t(Xfpc[idx1,] \%*\% phi1))
X[idx2,] = t(mu2 + t(Xfpc[idx2,] \%*\% phi2))

X1 = X[idx1,]; X2 = X[idx2,]

res = depthInfer2test(X1, X2, Mproj=15)

}
\references{
Yeon, H. (2026+) Effective and flexible depth-based inference for functional parameters. In preparation
}
\seealso{
\code{\link{KD}}
\code{\link{RegDepth}}
\code{\link{depthInferFoFR}}
}
